import random
import sys
from abc import ABC, abstractmethod
from dataclasses import dataclass
from numbers import Number

from vrpu.solver.local.moves import IMove, RelocateMove, SwapMove, ShiftMove
from vrpu.solver.local.objective import IObjectiveFunction
from vrpu.solver.solution_encoding import EncodedSolution


@dataclass
class Neighbor:
    move: IMove = None
    value: Number = None
    solution: EncodedSolution = None


class INeighborhoodGenerator(ABC):
    """
    Interface. A Neighborhood represents a set of solutions generated by applying a single move on a given solution.
    """

    @abstractmethod
    def generate_neighborhood(self, solution: EncodedSolution, **kwargs) -> [Neighbor]:
        """
        Generates a neighborhood of a given solution.
        :param solution: The solution.
        :param kwargs: Key worded arguments.
        :return: A list of neighbor solution of the given solution.
        """
        pass

    @abstractmethod
    def get_max_steps(self) -> int:
        """
        :return: How many different steps are supported by this generator.
        If the complete neighborhood is always generated in a single step, then 1 should be returned.
        """
        pass

    def is_neighbor_valid(self, neighbor: EncodedSolution) -> bool:
        """
        :param neighbor: The neighbor to check.
        :return: Whether the neighbor is valid. Here: Checks capacity constraint.
        """
        max_loads = neighbor.get_max_loads()
        for vehicle, load in max_loads.items():
            if load > neighbor.vehicles[vehicle].max_capacity:
                return False
        return True


class CyclicNeighborhoodGeneratorCVRP(INeighborhoodGenerator):

    def __init__(self):
        self.step_methods = {
            0: self._generate_shifts,
            1: self._generate_relocates,
            2: self._generate_swaps,
        }

    def generate_neighborhood(self, solution: EncodedSolution, **kwargs) -> [Neighbor]:
        """
        Generates a neighborhood of a given solution.
        :param solution: The solution.
        :param kwargs: Key worded arguments.
            :keyword step: The current step in the cycle.
            :keyword greedy: Whether the first better neighbor shall be returned.
            :keyword best_value: The current best value.
            :keyword objective: The objective function used for evaluation.
        :return: A list of neighbor solution of the given solution.
        """
        step = kwargs.get('iteration', 0)
        greedy = kwargs.get('greedy', True)
        best_value = kwargs.get('best_value', sys.maxsize)
        objective_function: IObjectiveFunction = kwargs.get('objective')

        moves = self.step_methods[step % self.get_max_steps()](solution)
        random.shuffle(moves)

        valid_neighbors = []

        for move in moves:
            neighbor = move.generate_neighbor(solution)
            if self.is_neighbor_valid(neighbor):

                # collect all valid neighbors
                if not greedy:
                    valid_neighbors.append(Neighbor(solution=neighbor, move=move))
                    continue

                # greedy: return first better neighbor
                value = objective_function.value(neighbor)
                if value < best_value:
                    return [Neighbor(solution=neighbor, move=move, value=value)]

        return valid_neighbors

    def get_max_steps(self) -> int:
        return 3

    def _generate_swaps(self, solution: EncodedSolution) -> [IMove]:
        # print(f"    Generating SWAP moves")
        moves = []
        for i in range(len(solution)):
            for j in range(i + 1, len(solution)):
                move = SwapMove([i], [j])
                moves.append(move)

        return moves

    def _generate_shifts(self, solution: EncodedSolution) -> [IMove]:
        # print(f"    Generating SHIFT moves")
        moves = []
        loads = solution.get_max_loads()

        for index, enc_action in enumerate(solution):
            for vehicle_index in range(len(solution.vehicles)):
                if vehicle_index == enc_action.vehicle_index:
                    continue
                if loads[vehicle_index] >= solution.vehicles[vehicle_index].max_capacity:
                    continue

                move = ShiftMove([index], vehicle_index)
                moves.append(move)

        return moves

    def _generate_relocates(self, solution: EncodedSolution) -> [IMove]:
        # print(f"    Generating RELOCATE moves")
        moves = []

        for i, encoded_action in enumerate(solution):
            for j, neighbor_action in enumerate(solution):
                if encoded_action.vehicle_index != neighbor_action.vehicle_index:
                    continue
                if i == j:
                    continue

                # move the action right after neighbor_action
                if encoded_action.value < neighbor_action.value:
                    value = neighbor_action.value + 1
                # move it before neighbor_action
                else:
                    value = neighbor_action.value - 1

                move = RelocateMove([i], [value])
                moves.append(move)

        return moves


class CyclicNeighborhoodGeneratorVRPDP(CyclicNeighborhoodGeneratorCVRP):
    def _generate_swaps(self, solution: EncodedSolution) -> [IMove]:
        moves = []
        for i in range(0, len(solution) - 1, 2):
            for j in range(i + 1, len(solution) - 1, 2):
                move = SwapMove([i, i + 1], [j, j + 1])
                moves.append(move)

        return moves

    def _generate_shifts(self, solution: EncodedSolution) -> [IMove]:
        moves = []

        for index in range(0, len(solution) - 1, 2):
            enc_action = solution[index]
            for vehicle_index in range(len(solution.vehicles)):
                if vehicle_index == enc_action.vehicle_index:
                    continue

                move = ShiftMove([index, index + 1], vehicle_index)
                moves.append(move)

        return moves

    def _generate_relocates(self, solution: EncodedSolution) -> [IMove]:
        moves = []

        for i in range(0, len(solution), 2):
            pick_action = solution[i]
            delivery_action = solution[i + 1]

            for j, neighbor_action in enumerate(solution):
                if pick_action.vehicle_index != neighbor_action.vehicle_index:
                    continue
                if i == j or i + 1 == j:
                    continue

                # keep the pickup action always before the corresponding delivery action
                if neighbor_action.value < delivery_action.value:
                    # move the action right after neighbor_action
                    if pick_action.value < neighbor_action.value:
                        value = neighbor_action.value + 1
                    # move it before neighbor_action
                    else:
                        value = neighbor_action.value - 1

                    move = RelocateMove([i], [value])
                    moves.append(move)

                # keep the delivery action always after the corresponding pickup action
                if neighbor_action.value > pick_action.value:
                    # move the action right after neighbor_action
                    if delivery_action.value < neighbor_action.value:
                        value = neighbor_action.value + 1
                    # move it before neighbor_action
                    else:
                        value = neighbor_action.value - 1

                    move = RelocateMove([i + 1], [value])
                    moves.append(move)

        return moves
